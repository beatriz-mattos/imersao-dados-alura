# -*- coding: utf-8 -*-
"""analise_microdados_enem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cdnNaoE4UuXKvOupUGan7dA1atnMnCha
"""

#importar bibliotecas básicas para análise de dados
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

#importar dados do ENEM
source = "https://github.com/alura-cursos/imersao-dados-2-2020/blob/master/MICRODADOS_ENEM_2019_SAMPLE_43278.csv?raw=true"
data = pd.read_csv(source) #importa os dados compartilhados (modo CSV - Comma Separated Values) e disponibilida no código como DataFrame

#Exploração rápida dos dados
print("Shape =", data.shape) #dimensão dos dados [linhas, colunas]
data.head() #visualização rápida dos dados (5 primeiras linhas do Dataframe)

data["SG_UF_RESIDENCIA"] #explorar APENAS uma coluna do DataFrame, por exemplo, a coluna de Estados no ENEM. Retorna todas as linhas do DataFrame para a coluna 'SG_UF_RESIDENCIA'

#O resultado de data['SG_UF_RESIDENCIA'] é diferente do resultado de data['SG_UF_RESIDENCIA'].head() => retorna apenas as 5 primeiras linhas para a coluna 'SG_UF_RESIDENCIA'

data.columns.values #Continuando a exploração dos dados, podemos averiguar quais são as 136 colunas do DataFrame

data[["SG_UF_RESIDENCIA", "NO_MUNICIPIO_RESIDENCIA"]] #caso queiramos verificar mais de 1 coluna, temos que inserir uma lista das colunas desejadas na busca do DataFrame

# * lista em python = []

data["SG_UF_RESIDENCIA"].unique() #para obter uma lista de todos os estados que têm pelo menos 1 participante na prova

len(data["SG_UF_RESIDENCIA"].unique()) #para facilitar a contagem, basta chamar a função len

#Agora sabemos que temos pelo menos 1 participante de cada UF. Mas quantos realmente temos no total por UF?

data["SG_UF_RESIDENCIA"].value_counts() #value_counts => cria uma tabela com os valores de participantes de cada UF

#Para ter melhor ideia dessa distribuição, melhor por no gráfico! Possibilidades: Usar o Matplotlib através do próprio Pandas ou usar outra biblioteca (Seaborn)

#Plotar gráfico com Pandas
data["SG_UF_RESIDENCIA"].value_counts().plot.bar(figsize=(20,5))

plt.title("Distribuição de participantes do ENEM por UF", fontsize=30) #título do gráfico

#Para deixar mais inteligível, pode-se nomear os eixos
plt.xlabel("UF", fontsize=20)
plt.ylabel("Participantes", fontsize=20)

#Plotar dados com Seaborn
plt.figure(figsize=(20,5))
sns.barplot(data["SG_UF_RESIDENCIA"].value_counts().index,
data["SG_UF_RESIDENCIA"].value_counts().values)

plt.title("Distribuição de participantes do ENEM por UF", fontsize=30)
plt.xlabel("UF", fontsize=20)
plt.ylabel("Participantes", fontsize=20)

#Agora, é possível verificar que o maior número de participantes do ENEM nessa amostra é de SP

#Para saber a proporção de participantes do ENEM por UF do total de participantes:
data["SG_UF_RESIDENCIA"].value_counts(normalize=True).sort_values(ascending=False).plot.bar(figsize=(20,5))
plt.title("Proporção[%] de participantes do ENEM por UF", fontsize=30)
plt.xlabel("UF", fontsize=20)
plt.ylabel("Participantes", fontsize=20)

#Explorando a distribuição dos participantes por faixa etária
data["NU_IDADE"].value_counts() #cria uma tabela com os valores de idades dos participantes

#aqui os dados estão ordenados pela MAIOR QUANTIDADE de pessoas com a idade, e não pela idade!

#ordenando os dados pela idade:
data["NU_IDADE"].value_counts().sort_index()

#Gráfico de barras
data["NU_IDADE"].value_counts().sort_index().plot.bar(figsize=(20,5))
plt.title("Distribuição etária dos participantes do ENEM 2019", fontsize=30)
plt.xlabel("Idade", fontsize=20)
plt.ylabel("Qte. de participantes", fontsize=20)

#Gráficos tipo Histograma => direto do Pandas + Matplotlib
plt.figure()
data["NU_IDADE"].hist(figsize=(20,5), bins=20) #bins são as colunas de divisão do histograma. Para que estes gráficos tenham a mesma distribuição, é preciso configurar esse parâmetro
plt.xlabel("Idade", fontsize=20)
plt.ylabel("Qtd. participantes", fontsize=20)
plt.title("Distribuição etária dos participantes do ENEM 2019", fontsize=25)

#Com Seaborn
plt.figure(figsize=(20,5))
sns.distplot(data["NU_IDADE"], kde=False, bins=20)
plt.xlabel("Idade", fontsize=20)
plt.ylabel("Qtd. participantes", fontsize=20)
plt.title("Distribuição etária dos participantes do ENEM 2019", fontsize=25)
plt.grid()

#Com estes gráficos, podemos concluir que a maior parte dos que prestam prova para o ENEM estão entre 16 e 25 anos.

#De quais estados são os inscritos com 13 anos?
data.query("NU_IDADE == 13")['SG_UF_RESIDENCIA'].unique()

#Proporção etária:
prop_idade = data["NU_IDADE"].value_counts().sort_index()/data.shape[0]*100 #incluindo .shape para saber a proporção de cada idade dentro do total de participantes
prop_idade.plot.bar(figsize=(20,5))
plt.title("Proporção[%] etária dos participantes do ENEM 2019", fontsize=30)
plt.xlabel("Idade", fontsize=20)
plt.ylabel("Proporção participantes", fontsize=20)
plt.grid()

#Dentro do ENEM, existe uma categoria de participantes chamada Treineiro. Este realiza a prova como qualquer outro participante sem entrar no processo de seleção de vestibular, apenas para ganhar experiência e se preparar para os anos seguintes.
#Nos dados pode-se ver que existem participantes com idade inferior às que normalmente se espera para a prova (17 a 18 anos). Quantos desses participantes são ou não treineiros?

#treineiro => 1, não-treineiro => 0
treineiro = data.loc[data["IN_TREINEIRO"] == 1, "NU_IDADE"]
nao_treineiro = data.loc[data["IN_TREINEIRO"] == 0, "NU_IDADE"]

#Gráfico pandas + matplotlib
nao_treineiro.hist(bins=40, figsize=(20,5), label="Concorrência geral")
treineiro.hist(bins=40, figsize=(20,5), label="Treineiro")
plt.legend(fontsize=15)
plt.xlabel("Idade", fontsize=20)
plt.ylabel("Qtd. participantes", fontsize=20)
plt.title("Distribuição etária dos participantes do Enem 2019", fontsize=25)

#Conforme esperado, a maioria dos candidatos que prestam a prova como treineiros possuem menos de 20 anos.

#Avaliar a distribuição das notas na prova de Redação + Linguagem e Comunicação

#Notas redação
plt.figure()
data["NU_NOTA_REDACAO"].hist(figsize=(10,5), bins=20)
plt.xlabel("Nota", fontsize=20)
plt.ylabel("Ocorrência", fontsize=20)
plt.title("Distribuição de notas de redação", fontsize=25)

plt.figure()
data["NU_NOTA_LC"].hist(figsize=(10,5), bins=20)
plt.xlabel("Nota", fontsize=20)
plt.ylabel("Ocorrência", fontsize=20)
plt.title("Distribuição de notas de Linguagem e Comunicação", fontsize=25)

#É interessante observar que a distribuição de notas na prova de redação é bem ampla quando comparada com a distribuição das notas de LC. Além disso, há uma maior ocorrência de participantes que zeraram a nota em redação.

#O Pandas permite que façamos uma exploração rápida dos dados e avaliemos dados como média, mediana e quartis
data["NU_NOTA_LC"].describe() #o comando describe retorna uma visão resumida dos dados

#A avaliação de um parâmetro isoladamente pode não fazer muito sentido quando usamos esse comando. Porém o Pandas permite que façamos comparações com variáveis.
provas = ["NU_NOTA_LC", "NU_NOTA_REDACAO"]
data[provas].describe()

#a mesma comparação, mas de forma gráfica
provas = ["NU_NOTA_LC", "NU_NOTA_REDACAO"]
data[provas].plot.box(figsize=(10, 10), grid=True)

#É possível verificar o comportamento conforme descrito anteriormente, no qual a distribuição das notas encontra-se mais aberta para as notas de redação. Isso pode ser visto na região da caixa onde esta, que representa a região com maior concentração das notas é significativamente maior que a caixa das notas de LC.
#É possível também ter nesse gráfico de forma visual as informações de quartis (de baixo para cima: 25%, 50% e 75% ) na forma de traços no gráfico.